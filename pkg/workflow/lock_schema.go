package workflow

import (
	"encoding/json"
	"fmt"
	"regexp"
	"strings"

	"github.com/github/gh-aw/pkg/logger"
)

var lockSchemaLog = logger.New("workflow:lock_schema")

// LockSchemaVersion represents a lock file schema version
type LockSchemaVersion string

const (
	// LockSchemaV1 is the current lock file schema version
	LockSchemaV1 LockSchemaVersion = "v1"
)

// LockMetadata represents the structured metadata embedded in lock files
type LockMetadata struct {
	SchemaVersion   LockSchemaVersion `json:"schema_version"`
	FrontmatterHash string            `json:"frontmatter_hash,omitempty"`
	StopTime        string            `json:"stop_time,omitempty"`
	CompilerVersion string            `json:"compiler_version,omitempty"`
}

// SupportedSchemaVersions lists all schema versions this build can consume
var SupportedSchemaVersions = []LockSchemaVersion{
	LockSchemaV1,
}

// IsSchemaVersionSupported checks if a schema version is supported
func IsSchemaVersionSupported(version LockSchemaVersion) bool {
	for _, v := range SupportedSchemaVersions {
		if v == version {
			return true
		}
	}
	return false
}

// ExtractMetadataFromLockFile extracts structured metadata from a lock file's comment header
// Returns metadata and whether legacy format (no metadata) was detected
func ExtractMetadataFromLockFile(content string) (*LockMetadata, bool, error) {
	// Look for JSON metadata in comments (format: # gh-aw-metadata: {...})
	// Use .+ to capture to end of line since metadata is single-line JSON
	metadataPattern := regexp.MustCompile(`#\s*gh-aw-metadata:\s*(\{.+\})`)
	matches := metadataPattern.FindStringSubmatch(content)

	if len(matches) >= 2 {
		jsonStr := matches[1]
		var metadata LockMetadata
		if err := json.Unmarshal([]byte(jsonStr), &metadata); err != nil {
			return nil, false, fmt.Errorf("failed to parse lock metadata JSON: %w", err)
		}
		lockSchemaLog.Printf("Extracted metadata from lock file: schema=%s", metadata.SchemaVersion)
		return &metadata, false, nil
	}

	// Legacy format: look for frontmatter-hash without JSON metadata
	hashPattern := regexp.MustCompile(`#\s*frontmatter-hash:\s*([0-9a-f]{64})`)
	if hashPattern.MatchString(content) {
		lockSchemaLog.Print("Legacy lock file detected (no schema version)")
		return nil, true, nil
	}

	// No metadata found at all
	return nil, false, nil
}

// ValidateLockSchemaCompatibility validates that a lock file's schema is compatible
// Returns an error with actionable guidance if incompatible
func ValidateLockSchemaCompatibility(content string, lockFilePath string) error {
	metadata, isLegacy, err := ExtractMetadataFromLockFile(content)
	if err != nil {
		return fmt.Errorf("failed to extract metadata from %s: %w", lockFilePath, err)
	}

	// Legacy files (no schema version) are supported for backward compatibility
	if isLegacy {
		lockSchemaLog.Printf("Legacy lock file accepted: %s", lockFilePath)
		return nil
	}

	// Missing metadata entirely is suspicious
	if metadata == nil {
		return fmt.Errorf("lock file %s is missing required metadata. This file may be corrupted or manually edited.\n\nTo fix this, recompile the workflow:\n  gh aw compile %s",
			lockFilePath,
			strings.TrimSuffix(lockFilePath, ".lock.yml")+".md")
	}

	// Check schema compatibility
	if !IsSchemaVersionSupported(metadata.SchemaVersion) {
		// Future version detected
		return fmt.Errorf("lock file %s uses unsupported schema version '%s'.\n\nThis file was generated by a newer version of gh-aw that uses incompatible features.\n\nSupported versions: %s\n\nTo fix this:\n  1. Upgrade gh-aw: gh extension upgrade gh-aw\n  2. Or downgrade the lock file by editing the source .md file and recompiling:\n     gh aw compile %s",
			lockFilePath,
			metadata.SchemaVersion,
			formatSupportedVersions(),
			strings.TrimSuffix(lockFilePath, ".lock.yml")+".md")
	}

	lockSchemaLog.Printf("Lock file schema validated: %s (version=%s)", lockFilePath, metadata.SchemaVersion)
	return nil
}

// formatSupportedVersions formats the list of supported versions for error messages
func formatSupportedVersions() string {
	versions := make([]string, len(SupportedSchemaVersions))
	for i, v := range SupportedSchemaVersions {
		versions[i] = string(v)
	}
	return strings.Join(versions, ", ")
}

// GenerateLockMetadata creates a LockMetadata struct for embedding in lock files
// For release builds, the compiler version is included in the metadata
func GenerateLockMetadata(frontmatterHash string, stopTime string) *LockMetadata {
	metadata := &LockMetadata{
		SchemaVersion:   LockSchemaV1,
		FrontmatterHash: frontmatterHash,
		StopTime:        stopTime,
	}

	// Include compiler version only for release builds
	if IsRelease() {
		metadata.CompilerVersion = GetVersion()
	}

	return metadata
}

// ToJSON converts LockMetadata to a compact JSON string for embedding in comments
func (m *LockMetadata) ToJSON() (string, error) {
	bytes, err := json.Marshal(m)
	if err != nil {
		return "", fmt.Errorf("failed to serialize lock metadata: %w", err)
	}
	return string(bytes), nil
}
