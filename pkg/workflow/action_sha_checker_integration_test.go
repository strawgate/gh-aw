//go:build integration

package workflow

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/github/gh-aw/pkg/testutil"
)

// TestActionSHAValidationIntegration tests the complete SHA validation flow
func TestActionSHAValidationIntegration(t *testing.T) {
	// Create a temporary directory for testing
	tmpDir := testutil.TempDir(t, "test-*")

	// Create an actions-lock.json cache file with test data
	cacheDir := filepath.Join(tmpDir, ".github", "aw")
	if err := os.MkdirAll(cacheDir, 0755); err != nil {
		t.Fatalf("Failed to create cache directory: %v", err)
	}

	// Create a cache with some pre-populated data
	cache := NewActionCache(tmpDir)

	// Pre-populate cache with "current" SHAs
	cache.Set("actions/checkout", "v5", "93cb6efe18208431cddfb8368fd83d5badbf9bfd")
	cache.Set("actions/setup-node", "v6", "395ad3262231945c25e8478fd5baf05154b1d79f")

	// Save the cache
	if err := cache.Save(); err != nil {
		t.Fatalf("Failed to save cache: %v", err)
	}

	// Create a lock file with the same SHAs (up-to-date scenario)
	lockFile := filepath.Join(tmpDir, "test.lock.yml")
	lockContent := `# gh-aw-metadata: {"schema_version":"v1"}
name: Test Workflow
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd
      - uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f
`

	if err := os.WriteFile(lockFile, []byte(lockContent), 0644); err != nil {
		t.Fatalf("Failed to create lock file: %v", err)
	}

	// Test 1: Validation with up-to-date actions (should not error)
	t.Run("UpToDate", func(t *testing.T) {
		err := ValidateActionSHAsInLockFile(lockFile, cache, false)
		if err != nil {
			t.Errorf("Unexpected error with up-to-date actions: %v", err)
		}
	})

	// Create a lock file with outdated SHAs
	outdatedLockFile := filepath.Join(tmpDir, "outdated.lock.yml")
	outdatedContent := `# gh-aw-metadata: {"schema_version":"v1"}
name: Test Workflow
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@0000000000000000000000000000000000000000
      - uses: actions/setup-node@1111111111111111111111111111111111111111
`

	if err := os.WriteFile(outdatedLockFile, []byte(outdatedContent), 0644); err != nil {
		t.Fatalf("Failed to create outdated lock file: %v", err)
	}

	// Test 2: Validation with outdated actions (should emit warnings but not error)
	t.Run("Outdated", func(t *testing.T) {
		// Note: This will emit warnings to stderr, but should not return an error
		err := ValidateActionSHAsInLockFile(outdatedLockFile, cache, false)
		if err != nil {
			t.Errorf("Unexpected error with outdated actions: %v", err)
		}
	})
}

// TestActionSHAValidationWithMissingCache tests validation when cache doesn't exist
func TestActionSHAValidationWithMissingCache(t *testing.T) {
	tmpDir := testutil.TempDir(t, "test-*")

	// Create a lock file
	lockFile := filepath.Join(tmpDir, "test.lock.yml")
	lockContent := `# gh-aw-metadata: {"schema_version":"v1"}
name: Test Workflow
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd
`

	if err := os.WriteFile(lockFile, []byte(lockContent), 0644); err != nil {
		t.Fatalf("Failed to create lock file: %v", err)
	}

	// Create cache but don't pre-populate it (simulates first run)
	cache := NewActionCache(tmpDir)

	// Validation should handle missing cache gracefully
	err := ValidateActionSHAsInLockFile(lockFile, cache, false)
	if err != nil {
		t.Errorf("Unexpected error with missing cache: %v", err)
	}
}

// TestExtractActionsFromRealLockFile tests extraction from a realistic lock file
func TestExtractActionsFromRealLockFile(t *testing.T) {
	tmpDir := testutil.TempDir(t, "test-*")
	lockFile := filepath.Join(tmpDir, "realistic.lock.yml")

	// Create a more realistic lock file with multiple jobs and steps
	lockContent := `# gh-aw-metadata: {"schema_version":"v1"}
# This file was automatically generated by gh-aw
name: CI Workflow
on:
  push:
    branches: [main]
  pull_request:

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f
        with:
          node-version: '20'

      - name: Run tests
        run: npm test

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd
      - name: Upload artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f
        with:
          name: results
          path: ./dist
`

	if err := os.WriteFile(lockFile, []byte(lockContent), 0644); err != nil {
		t.Fatalf("Failed to create lock file: %v", err)
	}

	actions, err := ExtractActionsFromLockFile(lockFile)
	if err != nil {
		t.Fatalf("Failed to extract actions: %v", err)
	}

	// Should find 3 unique actions (checkout appears twice but should be deduplicated)
	if len(actions) != 3 {
		t.Errorf("Expected 3 unique actions, got %d", len(actions))
	}

	// Verify we found the expected actions
	foundRepos := make(map[string]bool)
	for _, action := range actions {
		foundRepos[action.Repo] = true
	}

	expectedRepos := []string{
		"actions/checkout",
		"actions/setup-node",
		"actions/upload-artifact",
	}

	for _, expected := range expectedRepos {
		if !foundRepos[expected] {
			t.Errorf("Expected to find action %s", expected)
		}
	}
}

// TestValidationMessageFormat tests that validation messages are properly formatted
func TestValidationMessageFormat(t *testing.T) {
	tmpDir := testutil.TempDir(t, "test-*")
	lockFile := filepath.Join(tmpDir, "test.lock.yml")

	lockContent := `# gh-aw-metadata: {"schema_version":"v1"}
name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd
`

	if err := os.WriteFile(lockFile, []byte(lockContent), 0644); err != nil {
		t.Fatalf("Failed to create lock file: %v", err)
	}

	cache := NewActionCache(tmpDir)
	cache.Set("actions/checkout", "v5", "93cb6efe18208431cddfb8368fd83d5badbf9bfd")

	// Capture stderr output to verify message format
	// Note: In a real scenario, we'd redirect stderr, but for this test
	// we just ensure it doesn't error
	err := ValidateActionSHAsInLockFile(lockFile, cache, true)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
}

// TestActionUsageVersionPopulation tests that version is populated from action_pins.json
func TestActionUsageVersionPopulation(t *testing.T) {
	tmpDir := testutil.TempDir(t, "test-*")
	lockFile := filepath.Join(tmpDir, "test.lock.yml")

	// Use an action that exists in action_pins.json
	lockContent := `# gh-aw-metadata: {"schema_version":"v1"}
name: Test
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd
`

	if err := os.WriteFile(lockFile, []byte(lockContent), 0644); err != nil {
		t.Fatalf("Failed to create lock file: %v", err)
	}

	actions, err := ExtractActionsFromLockFile(lockFile)
	if err != nil {
		t.Fatalf("Failed to extract actions: %v", err)
	}

	// Check that actions/checkout has its version populated
	found := false
	for _, action := range actions {
		if action.Repo == "actions/checkout" {
			found = true
			if action.Version == "" {
				t.Error("Expected version to be populated for actions/checkout")
			}
			if !strings.HasPrefix(action.Version, "v") {
				t.Errorf("Expected version to start with 'v', got: %s", action.Version)
			}
		}
	}

	if !found {
		t.Error("Expected to find actions/checkout in extracted actions")
	}
}
