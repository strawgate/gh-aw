package cli

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/github/gh-aw/pkg/console"
	"github.com/github/gh-aw/pkg/logger"
)

var firewallLogLog = logger.New("cli:firewall_log")

// Pre-compiled regexes for firewall log parsing (performance optimization)
var (
	firewallLogFieldSplitter = regexp.MustCompile(`(?:[^\s"]+|"[^"]*")+`)
)

// Firewall Log Parser
//
// This package provides a Go implementation of the firewall logs parser that mirrors
// the JavaScript parser in pkg/workflow/js/parse_firewall_logs.cjs. It parses firewall
// proxy logs generated by agentic workflows to track network access patterns.
//
// # Log Format
//
// Firewall logs use a space-separated format with 10 fields:
//   timestamp client_ip:port domain dest_ip:port proto method status decision url user_agent
//
// Example log entries:
//   1761332530.474 172.30.0.20:35288 api.enterprise.githubcopilot.com:443 140.82.112.22:443 1.1 CONNECT 200 TCP_TUNNEL:HIER_DIRECT api.enterprise.githubcopilot.com:443 "-"
//   1761332531.123 172.30.0.20:35289 blocked.example.com:443 140.82.112.23:443 1.1 CONNECT 403 NONE_NONE:HIER_NONE blocked.example.com:443 "-"
//
// # Field Mapping
//
// This parser maintains field-for-field parity with the JavaScript parser:
//  1. timestamp     - Unix timestamp with decimal (e.g., "1761332530.474")
//  2. client_ip:port - Client IP and port (e.g., "172.30.0.20:35288") or "-"
//  3. domain        - Target domain:port (e.g., "api.github.com:443") or "-"
//  4. dest_ip:port  - Destination IP and port (e.g., "140.82.112.22:443") or "-"
//  5. proto         - Protocol version (e.g., "1.1") or "-"
//  6. method        - HTTP method (e.g., "CONNECT", "GET") or "-"
//  7. status        - HTTP status code (e.g., "200", "403") or "0"
//  8. decision      - Proxy decision (e.g., "TCP_TUNNEL:HIER_DIRECT") or "-"
//  9. url           - Request URL (e.g., "api.github.com:443") or "-"
// 10. user_agent    - User agent string (quoted, e.g., "Mozilla/5.0" or "-")
//
// # Normalization and Error Handling
//
// - Comment lines (starting with #) are skipped
// - Empty lines are skipped
// - Lines with fewer than 10 fields are rejected
// - Only timestamp field is validated (must be numeric with optional decimal point)
// - Other fields are accepted as-is without validation (matches JavaScript parser behavior)
// - User agent quotes are automatically stripped
//
// # Request Classification
//
// Requests are classified as allowed or denied based on status code and decision:
//
// Allowed indicators:
//   - Status codes: 200, 206, 304
//   - Decisions containing: TCP_TUNNEL, TCP_HIT, TCP_MISS
//
// Denied indicators:
//   - Status codes: 403, 407
//   - Decisions containing: NONE_NONE, TCP_DENIED
//
// Default: Denied (for safety when classification is ambiguous)
//
// # Output Examples
//
// Console output (via console.RenderStruct):
//   ðŸ”¥ Firewall Log Analysis
//   Total Requests : 4
//   Allowed        : 2
//   Denied         : 2
//
// JSON output:
//   {
//     "total_requests": 4,
//     "allowed_requests": 2,
//     "blocked_requests": 2,
//     "allowed_domains": ["api.github.com:443", "api.npmjs.org:443"],
//     "blocked_domains": ["blocked.example.com:443", "blocked.test.com:443"],
//     "requests_by_domain": {
//       "api.github.com:443": {"allowed": 1, "blocked": 0},
//       "blocked.example.com:443": {"allowed": 0, "blocked": 1}
//     }
//   }

// FirewallLogEntry represents a parsed firewall log entry
// Format: timestamp client_ip:port domain dest_ip:port proto method status decision url user_agent
type FirewallLogEntry struct {
	Timestamp    string
	ClientIPPort string
	Domain       string
	DestIPPort   string
	Proto        string
	Method       string
	Status       string
	Decision     string
	URL          string
	UserAgent    string
}

// FirewallAnalysis represents analysis of firewall logs
// This mirrors the structure from the JavaScript parser
type FirewallAnalysis struct {
	DomainBuckets
	TotalRequests    int                           `json:"total_requests"`
	AllowedRequests  int                           `json:"allowed_requests"`
	BlockedRequests  int                           `json:"blocked_requests"`
	RequestsByDomain map[string]DomainRequestStats `json:"requests_by_domain,omitempty"`
}

// AddMetrics adds metrics from another analysis
func (f *FirewallAnalysis) AddMetrics(other LogAnalysis) {
	if otherFirewall, ok := other.(*FirewallAnalysis); ok {
		f.TotalRequests += otherFirewall.TotalRequests
		f.AllowedRequests += otherFirewall.AllowedRequests
		f.BlockedRequests += otherFirewall.BlockedRequests

		// Merge request stats by domain
		for domain, stats := range otherFirewall.RequestsByDomain {
			existing := f.RequestsByDomain[domain]
			existing.Allowed += stats.Allowed
			existing.Blocked += stats.Blocked
			f.RequestsByDomain[domain] = existing
		}
	}
}

// DomainRequestStats tracks request statistics per domain
type DomainRequestStats struct {
	Allowed int `json:"allowed"`
	Blocked int `json:"blocked"`
}

// parseFirewallLogLine parses a single firewall log line
// Format: timestamp client_ip:port domain dest_ip:port proto method status decision url user_agent
// Returns nil if the line is invalid or should be skipped
func parseFirewallLogLine(line string) *FirewallLogEntry {
	trimmed := strings.TrimSpace(line)
	if trimmed == "" || strings.HasPrefix(trimmed, "#") {
		return nil
	}

	// Split by whitespace but preserve quoted strings
	// This regex matches non-whitespace sequences or quoted strings
	fields := firewallLogFieldSplitter.FindAllString(trimmed, -1)

	if len(fields) < 10 {
		return nil
	}

	// Only validate timestamp (essential for log format detection)
	// This matches the JavaScript parser behavior which only validates timestamp
	timestamp := fields[0]
	if matched, _ := regexp.MatchString(`^\d+(\.\d+)?$`, timestamp); !matched {
		return nil
	}

	// Extract fields without validation (matches JavaScript parser)
	clientIPPort := fields[1]
	domain := fields[2]
	destIPPort := fields[3]
	status := fields[6]
	decision := fields[7]

	// Remove quotes from user agent
	userAgent := fields[9]
	userAgent = strings.Trim(userAgent, `"`)

	return &FirewallLogEntry{
		Timestamp:    timestamp,
		ClientIPPort: clientIPPort,
		Domain:       domain,
		DestIPPort:   destIPPort,
		Proto:        fields[4],
		Method:       fields[5],
		Status:       status,
		Decision:     decision,
		URL:          fields[8],
		UserAgent:    userAgent,
	}
}

// isRequestAllowed determines if a request was allowed based on decision and status
// This mirrors the logic from the JavaScript parser
func isRequestAllowed(decision, status string) bool {
	// Check status code first
	if statusCode, err := strconv.Atoi(status); err == nil {
		if statusCode == 200 || statusCode == 206 || statusCode == 304 {
			return true
		}
		if statusCode == 403 || statusCode == 407 {
			return false
		}
	}

	// Check decision field
	if strings.Contains(decision, "TCP_TUNNEL") ||
		strings.Contains(decision, "TCP_HIT") ||
		strings.Contains(decision, "TCP_MISS") {
		return true
	}

	if strings.Contains(decision, "NONE_NONE") ||
		strings.Contains(decision, "TCP_DENIED") {
		return false
	}

	// Default to denied for safety
	return false
}

// parseFirewallLog parses a firewall log file and returns analysis
func parseFirewallLog(logPath string, verbose bool) (*FirewallAnalysis, error) {
	firewallLogLog.Printf("Parsing firewall log: %s", logPath)
	file, err := os.Open(logPath)
	if err != nil {
		firewallLogLog.Printf("Failed to open firewall log: %v", err)
		return nil, fmt.Errorf("failed to open firewall log: %w", err)
	}
	defer file.Close()

	analysis := &FirewallAnalysis{
		RequestsByDomain: make(map[string]DomainRequestStats),
	}

	allowedDomainsSet := make(map[string]bool)
	blockedDomainsSet := make(map[string]bool)

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()

		entry := parseFirewallLogLine(line)
		if entry == nil {
			continue
		}

		analysis.TotalRequests++

		// Determine if request was allowed or blocked
		isAllowed := isRequestAllowed(entry.Decision, entry.Status)

		// Extract domain (remove port)
		domain := entry.Domain

		if isAllowed {
			analysis.AllowedRequests++
			if !allowedDomainsSet[domain] {
				allowedDomainsSet[domain] = true
			}
		} else {
			analysis.BlockedRequests++
			if !blockedDomainsSet[domain] {
				blockedDomainsSet[domain] = true
			}
		}

		// Track request count per domain
		stats := analysis.RequestsByDomain[domain]
		if isAllowed {
			stats.Allowed++
		} else {
			stats.Blocked++
		}
		analysis.RequestsByDomain[domain] = stats
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading firewall log: %w", err)
	}

	// Convert sets to sorted slices
	for domain := range allowedDomainsSet {
		analysis.AllowedDomains = append(analysis.AllowedDomains, domain)
	}
	for domain := range blockedDomainsSet {
		analysis.BlockedDomains = append(analysis.BlockedDomains, domain)
	}

	sort.Strings(analysis.AllowedDomains)
	sort.Strings(analysis.BlockedDomains)

	if firewallLogLog.Enabled() {
		firewallLogLog.Printf("Firewall log parsed: total=%d, allowed=%d, blocked=%d, allowed_domains=%d, blocked_domains=%d",
			analysis.TotalRequests, analysis.AllowedRequests, analysis.BlockedRequests,
			len(analysis.AllowedDomains), len(analysis.BlockedDomains))
	}
	return analysis, nil
}

// analyzeFirewallLogs analyzes firewall logs in a run directory
// Firewall logs are stored in /tmp/gh-aw/squid-logs-{workflow-name}/ during execution
// and uploaded as artifacts to the logs directory
func analyzeFirewallLogs(runDir string, verbose bool) (*FirewallAnalysis, error) {
	firewallLogLog.Printf("Analyzing firewall logs in: %s", runDir)
	// Look for firewall logs in the run directory
	// The logs could be in several locations depending on how they were uploaded

	// First, check for sandbox/firewall/logs/ directory (new path after artifact download)
	// Firewall logs are uploaded from /tmp/gh-aw/sandbox/firewall/logs/ and the common parent
	// /tmp/gh-aw/ is stripped during artifact upload, resulting in sandbox/firewall/logs/ after download
	sandboxFirewallLogsDir := filepath.Join(runDir, "sandbox", "firewall", "logs")
	if _, err := os.Stat(sandboxFirewallLogsDir); err == nil {
		firewallLogLog.Printf("Found firewall logs directory: sandbox/firewall/logs")
		if verbose {
			fmt.Fprintln(os.Stderr, console.FormatInfoMessage("Found firewall logs directory: sandbox/firewall/logs"))
		}
		return analyzeMultipleFirewallLogs(sandboxFirewallLogsDir, verbose)
	}

	// Second, check for directories starting with squid-logs or firewall-logs (legacy paths)
	// The actual directories may have workflow-specific suffixes like:
	// - squid-logs-smoke-copilot-firewall
	// - squid-logs-changeset-generator
	// - firewall-logs-{workflow-name}
	entries, err := os.ReadDir(runDir)
	if err != nil {
		firewallLogLog.Printf("Failed to read run directory: %v", err)
		return nil, fmt.Errorf("failed to read run directory: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		name := entry.Name()
		if strings.HasPrefix(name, "squid-logs") || strings.HasPrefix(name, "firewall-logs") {
			logsDir := filepath.Join(runDir, name)
			firewallLogLog.Printf("Found firewall logs directory: %s", name)
			if verbose {
				fmt.Fprintln(os.Stderr, console.FormatInfoMessage(fmt.Sprintf("Found firewall logs directory: %s", name)))
			}
			return analyzeMultipleFirewallLogs(logsDir, verbose)
		}
	}

	// Check for individual log files in the run directory
	files, err := filepath.Glob(filepath.Join(runDir, "*.log"))
	if err != nil {
		return nil, fmt.Errorf("failed to find firewall log files: %w", err)
	}

	// Filter for firewall log files (they typically have "access" or "firewall" in the name)
	var firewallLogs []string
	for _, file := range files {
		basename := filepath.Base(file)
		if strings.Contains(basename, "firewall") ||
			(strings.Contains(basename, "access") && !strings.Contains(basename, "access-")) {
			firewallLogs = append(firewallLogs, file)
		}
	}

	if len(firewallLogs) == 0 {
		firewallLogLog.Print("No firewall logs found")
		if verbose {
			fmt.Fprintln(os.Stderr, console.FormatInfoMessage(fmt.Sprintf("No firewall logs found in %s", runDir)))
		}
		return nil, nil
	}

	// Parse the first firewall log file found
	firewallLogLog.Printf("Found %d firewall log files, analyzing first: %s", len(firewallLogs), filepath.Base(firewallLogs[0]))
	if verbose {
		fmt.Fprintln(os.Stderr, console.FormatInfoMessage(fmt.Sprintf("Analyzing firewall log: %s", filepath.Base(firewallLogs[0]))))
	}

	return parseFirewallLog(firewallLogs[0], verbose)
}

// analyzeMultipleFirewallLogs analyzes multiple firewall log files in a directory
func analyzeMultipleFirewallLogs(logsDir string, verbose bool) (*FirewallAnalysis, error) {
	return aggregateLogFiles(
		logsDir,
		"*.log",
		verbose,
		parseFirewallLog,
		func() *FirewallAnalysis {
			return &FirewallAnalysis{
				RequestsByDomain: make(map[string]DomainRequestStats),
			}
		},
	)
}
