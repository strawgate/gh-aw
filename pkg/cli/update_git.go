package cli

import (
	"fmt"
	"math/rand"
	"os"
	"os/exec"
	"strings"

	"github.com/github/gh-aw/pkg/console"
	"github.com/github/gh-aw/pkg/logger"
	"github.com/github/gh-aw/pkg/workflow"
)

var updateGitLog = logger.New("cli:update_git")

// hasGitChanges checks if there are any uncommitted changes
func hasGitChanges() (bool, error) {
	cmd := exec.Command("git", "status", "--porcelain")
	output, err := cmd.Output()
	if err != nil {
		return false, fmt.Errorf("failed to check git status: %w", err)
	}

	hasChanges := len(strings.TrimSpace(string(output))) > 0
	updateGitLog.Printf("Git changes detected: %t", hasChanges)
	return hasChanges, nil
}

// runGitCommand runs a git command with the specified arguments
func runGitCommand(args ...string) error {
	cmd := exec.Command("git", args...)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("git %s failed: %w", strings.Join(args, " "), err)
	}
	return nil
}

// createUpdatePR creates a pull request with the workflow changes
func createUpdatePR(verbose bool) error {
	updateGitLog.Print("Creating update PR for workflow changes")
	// Check if GitHub CLI is available
	if !isGHCLIAvailable() {
		return fmt.Errorf("GitHub CLI (gh) is required for PR creation but not found in PATH")
	}

	// Check if there are any changes to commit
	hasChanges, err := hasGitChanges()
	if err != nil {
		return fmt.Errorf("failed to check git status: %w", err)
	}

	if !hasChanges {
		updateGitLog.Print("No git changes found, skipping PR creation")
		fmt.Fprintln(os.Stderr, console.FormatInfoMessage("No changes to create PR for"))
		return nil
	}

	if verbose {
		fmt.Fprintln(os.Stderr, console.FormatVerboseMessage("Creating pull request with workflow updates..."))
	}

	// Create a branch name with timestamp
	randomNum := rand.Intn(9000) + 1000 // Generate number between 1000-9999
	branchName := fmt.Sprintf("update-workflows-%d", randomNum)
	updateGitLog.Printf("Creating branch: %s", branchName)

	// Create and checkout new branch
	if err := runGitCommand("checkout", "-b", branchName); err != nil {
		return fmt.Errorf("failed to create branch: %w", err)
	}

	// Add all changes
	if err := runGitCommand("add", "."); err != nil {
		return fmt.Errorf("failed to add changes: %w", err)
	}

	// Commit changes
	commitMsg := "Update workflows and recompile"
	if err := runGitCommand("commit", "-m", commitMsg); err != nil {
		return fmt.Errorf("failed to commit changes: %w", err)
	}

	// Push branch
	if err := runGitCommand("push", "-u", "origin", branchName); err != nil {
		return fmt.Errorf("failed to push branch: %w", err)
	}

	// Create PR
	output, err := workflow.RunGHCombined("Creating pull request...", "pr", "create",
		"--title", "Update workflows and recompile",
		"--body", "This PR updates workflows from their source repositories and recompiles them.\n\nGenerated by `gh aw update --pr`")
	if err != nil {
		return fmt.Errorf("failed to create PR: %w\nOutput: %s", err, string(output))
	}

	fmt.Fprintln(os.Stderr, console.FormatSuccessMessage("Successfully created pull request"))
	fmt.Fprintln(os.Stderr, console.FormatInfoMessage(strings.TrimSpace(string(output))))

	return nil
}
