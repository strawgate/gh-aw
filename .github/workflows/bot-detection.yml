name: Bot Detection

on:
  workflow_dispatch:
  schedule:
    - cron: "0 * * * *"

permissions:
  contents: read
  pull-requests: read
  issues: write

jobs:
  detect-bots:
    runs-on: ubuntu-latest
    steps:
      - name: Detect brand new accounts with suspicious activity
        uses: actions/github-script@v7
        with:
          script: |
            const HOURS_BACK = 6;
            const MAX_PR = 50;
            const MIN_ACCOUNT_AGE_DAYS = 14;

            const cutoff = new Date(Date.now() - HOURS_BACK * 60 * 60 * 1000);

            const fs = require('fs');
            function appendSummary(markdown) {
              const summaryPath = process.env.GITHUB_STEP_SUMMARY;
              if (!summaryPath) return;
              fs.appendFileSync(summaryPath, `${markdown}\n`);
            }

            // Fetch recent PRs (up to MAX_PR)
            const prs = [];
            if (github.paginate?.iterator) {
              for await (const response of github.paginate.iterator(github.rest.pulls.list, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                sort: 'updated',
                direction: 'desc',
                per_page: 100,
              })) {
                prs.push(...response.data);
                if (prs.length >= MAX_PR) break;
              }
            } else {
              const { data } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                sort: 'updated',
                direction: 'desc',
                per_page: Math.min(100, MAX_PR),
              });
              prs.push(...data);
            }

            const highRiskAccounts = new Map();
            const commentsByUser = new Map();
            const userCreatedDates = new Map();
            const accountsSeen = new Set();
            let userLookupFailures = 0;

            async function ensureUserCreatedDate(login) {
              if (!login) return;
              accountsSeen.add(login);
              if (userCreatedDates.has(login)) return;
              try {
                const { data: userInfo } = await github.rest.users.getByUsername({ username: login });
                userCreatedDates.set(login, new Date(userInfo.created_at));
              } catch (e) {
                userLookupFailures += 1;
                userCreatedDates.set(login, null);
              }
            }

            for (const pr of prs.slice(0, MAX_PR)) {
              if (new Date(pr.updated_at) < cutoff) continue;

              await ensureUserCreatedDate(pr.user?.login);

              const issueComments = [];
              if (github.paginate?.iterator) {
                for await (const response of github.paginate.iterator(github.rest.issues.listComments, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  per_page: 100,
                })) {
                  issueComments.push(...response.data);
                }
              } else {
                const { data } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  per_page: 100,
                });
                issueComments.push(...data);
              }

              const reviewComments = [];
              if (github.paginate?.iterator) {
                for await (const response of github.paginate.iterator(github.rest.pulls.listReviewComments, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100,
                })) {
                  reviewComments.push(...response.data);
                }
              } else {
                const { data } = await github.rest.pulls.listReviewComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  per_page: 100,
                });
                reviewComments.push(...data);
              }

              for (const comment of [...issueComments, ...reviewComments]) {
                if (new Date(comment.created_at) < cutoff) continue;
                const login = comment.user?.login;
                if (!login) continue;

                await ensureUserCreatedDate(login);

                if (!commentsByUser.has(login)) {
                  commentsByUser.set(login, []);
                }
                commentsByUser.get(login).push({
                  pr: pr.number,
                  url: comment.html_url,
                  timestamp: comment.created_at,
                });
              }
            }

            // Also consider recent issue creators (not just PR comments).
            // This helps catch new accounts that only opened issues/PRs (even if already closed).
            try {
              const { data: recentIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'all',
                since: cutoff.toISOString(),
                per_page: 100,
              });

              for (const issue of recentIssues) {
                await ensureUserCreatedDate(issue.user?.login);
              }
            } catch (e) {
              // If issue listing fails, continue with PR/comment-based detection.
            }

            // Identify high-risk accounts
            const now = new Date();
            for (const [login, createdDate] of userCreatedDates) {
              if (!createdDate) continue;

              const daysOld = Math.floor((now - createdDate) / (24 * 60 * 60 * 1000));
              if (daysOld < MIN_ACCOUNT_AGE_DAYS) {
                highRiskAccounts.set(login, {
                  daysOld,
                  comments: commentsByUser.get(login) || [],
                  issues: [],
                  prs: [],
                });
              }
            }

            if (highRiskAccounts.size === 0) {
              let msg = `âœ… Bot Detection: no high-risk accounts (<${MIN_ACCOUNT_AGE_DAYS}d) detected in last ${HOURS_BACK}h.`;
              if (accountsSeen.size > 0) {
                msg += ` Checked ${accountsSeen.size} unique account(s).`;
              }
              if (userLookupFailures > 0) {
                msg += ` âš ï¸ ${userLookupFailures} account lookup(s) failed.`;
              }
              appendSummary(msg);
              return;
            }

            // Fetch additional activity for high-risk accounts
            for (const [login, data] of highRiskAccounts) {

              try {
                const { data: issues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  creator: login,
                  state: 'all',
                });
                data.issues = issues
                  .filter(i => !i.pull_request)
                  .filter(i => new Date(i.created_at) >= cutoff)
                  .map(i => ({
                    number: i.number,
                    title: i.title,
                    state: i.state,
                    created_at: i.created_at,
                    html_url: i.html_url,
                  }));
              } catch (e) {
                console.log(`Could not fetch issues for ${login}`);
              }

              try {
                const { data: prList } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'all',
                  per_page: 100,
                });
                data.prs = prList
                  .filter(p => p.user?.login === login && new Date(p.created_at) >= cutoff)
                  .map(p => ({
                    number: p.number,
                    title: p.title,
                    state: p.state,
                    created_at: p.created_at,
                    html_url: p.html_url,
                  }));
              } catch (e) {
                console.log(`Could not fetch PRs for ${login}`);
              }
            }

            // Skip alerting if everything found is already closed.
            let hasAnyOpenItem = false;
            for (const [, data] of highRiskAccounts) {
              if (data.issues?.some(i => i.state === 'open')) {
                hasAnyOpenItem = true;
                break;
              }
              if (data.prs?.some(p => p.state === 'open')) {
                hasAnyOpenItem = true;
                break;
              }
            }

            if (!hasAnyOpenItem) {
              console.log('No open issues or PRs from new accounts; skipping alert issue.');
              appendSummary('Bot Detection: flagged new accounts, but all related issues/PRs are closed. No alert issue created.');
              return;
            }

            // Build report
            const today = new Date().toISOString().split('T')[0];
            let body = `Recently-created accounts often indicate bots, spam accounts, or coordinated attacks.\n\n`;

            const sorted = Array.from(highRiskAccounts.entries()).sort((a, b) => a[1].daysOld - b[1].daysOld);

            for (const [login, data] of sorted) {
              body += `## @${login}\n`;
              body += `**Account age:** ${data.daysOld} day(s) old\n\n`;

              if (data.issues && data.issues.length > 0) {
                body += `### Issues Opened (${data.issues.length})\n`;
                for (const issue of data.issues) {
                  body += `- ${issue.html_url} (${issue.created_at})\n`;
                }
                body += `\n`;
              }

              if (data.prs && data.prs.length > 0) {
                body += `### Pull Requests Opened (${data.prs.length})\n`;
                for (const pr of data.prs) {
                  body += `- ${pr.html_url} (${pr.created_at})\n`;
                }
                body += `\n`;
              }

              if (data.comments && data.comments.length > 0) {
                body += `### Comments (${data.comments.length})\n`;
                for (const comment of data.comments.slice(0, 10)) {
                  body += `- ${comment.url} (${comment.timestamp})\n`;
                }
                if (data.comments.length > 10) {
                  body += `- ... and ${data.comments.length - 10} more comments\n`;
                }
                body += `\n`;
              }

              if (!data.issues?.length && !data.prs?.length && !data.comments?.length) {
                body += `*(No issues, PRs, or comments in the last ${HOURS_BACK} hours)*\n\n`;
              }
            }

            console.log('\nCreating security alert issue...');
              const title = `ðŸš¨ HIGH RISK: Brand New Accounts â€” ${today}`;
              let existingIssueNumber;

              try {
                const { data: existingIssues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 100,
                });

                const existing = existingIssues.find(i => i.title === title);
                if (existing?.number) {
                  existingIssueNumber = existing.number;
                }
              } catch (e) {
                // If listing issues fails, fall back to creating a new issue.
              }

            try {
                if (existingIssueNumber) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: existingIssueNumber,
                    body,
                  });
                } else {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title,
                    body,
                    labels: ['security', 'bot-detection'],
                  });
                }
            } catch (e) {
                console.log('Issue create/update with labels failed; retrying without labels...');
                if (existingIssueNumber) {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: existingIssueNumber,
                    body,
                  });
                } else {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title,
                    body,
                  });
                }
            }
