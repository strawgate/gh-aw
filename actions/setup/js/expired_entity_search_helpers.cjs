// @ts-check
/// <reference types="@actions/github-script" />

/**
 * Expired Entity Search Helpers
 *
 * NOTE: This module reads entity.body from GraphQL responses to check for workflow
 * markers and expiration patterns. No sanitization is needed as this is read-only
 * processing. The body content is used only for pattern matching, not for writing.
 */

const { EXPIRATION_PATTERN, LEGACY_EXPIRATION_PATTERN } = require("./ephemerals.cjs");
// SEC-004: No sanitize needed - entity.body is read-only (marker detection)

/**
 * Configuration for entity-specific GraphQL search
 * @typedef {Object} EntitySearchConfig
 * @property {string} entityType - Entity type name for logging (e.g., "issues", "pull requests", "discussions")
 * @property {string} graphqlField - GraphQL field name (e.g., "issues", "pullRequests", "discussions")
 * @property {string} resultKey - Key to use in return object (e.g., "issues", "pullRequests", "discussions")
 * @property {boolean} [enableDedupe] - Enable duplicate ID tracking (default: false)
 */

/**
 * Search statistics
 * @typedef {Object} SearchStats
 * @property {number} pageCount - Number of pages fetched
 * @property {number} totalScanned - Total number of entities scanned
 * @property {number} [duplicateCount] - Number of duplicates found (only if dedupe enabled)
 */

/**
 * Search result containing entities and statistics
 * @typedef {Object} SearchResult
 * @property {Array<{id: string, number: number, title: string, url: string, body: string, createdAt: string}>} items - Array of entities with expiration markers
 * @property {SearchStats} stats - Search statistics
 */

/**
 * Search for open entities with expiration markers using GraphQL pagination
 *
 * This function provides a generic implementation for searching GitHub entities
 * (issues, pull requests, discussions) that have:
 * 1. Agentic workflow markers (body contains "> AI generated by")
 * 2. Expiration markers (checkbox with expiration date)
 *
 * @param {any} github - GitHub GraphQL instance
 * @param {string} owner - Repository owner
 * @param {string} repo - Repository name
 * @param {EntitySearchConfig} config - Entity-specific configuration
 * @returns {Promise<SearchResult>} Search results with items and statistics
 */
async function searchEntitiesWithExpiration(github, owner, repo, config) {
  const items = [];
  const seenIds = config.enableDedupe ? new Set() : null;
  let hasNextPage = true;
  let cursor = null;
  let pageCount = 0;
  let totalScanned = 0;
  let duplicateCount = 0;

  core.info(`Starting GraphQL search for open ${config.entityType} in ${owner}/${repo}`);

  while (hasNextPage) {
    pageCount++;
    core.info(`Fetching page ${pageCount} of open ${config.entityType} (cursor: ${cursor || "initial"})`);

    const query = `
      query($owner: String!, $repo: String!, $cursor: String) {
        repository(owner: $owner, name: $repo) {
          ${config.graphqlField}(first: 100, after: $cursor, states: [OPEN]) {
            pageInfo {
              hasNextPage
              endCursor
            }
            nodes {
              id
              number
              title
              url
              body
              createdAt
            }
          }
        }
      }
    `;

    const result = await github.graphql(query, {
      owner: owner,
      repo: repo,
      cursor: cursor,
    });

    if (!result || !result.repository || !result.repository[config.graphqlField]) {
      core.warning(`GraphQL query returned no data at page ${pageCount}`);
      break;
    }

    const nodes = result.repository[config.graphqlField].nodes || [];
    totalScanned += nodes.length;
    core.info(`Page ${pageCount}: Retrieved ${nodes.length} open ${config.entityType} (total scanned: ${totalScanned})`);

    let agenticCount = 0;
    let withExpirationCount = 0;

    // Filter for entities with agentic workflow markers and expiration comments
    for (const entity of nodes) {
      // Check if created by an agentic workflow using XML comment markers
      // Look for either:
      // 1. <!-- gh-aw-workflow-id: ... --> (standalone workflow ID marker)
      // 2. <!-- gh-aw-agentic-workflow: ... --> (full metadata marker)
      const hasWorkflowId = entity.body && entity.body.includes("gh-aw-workflow-id:");
      const hasAgenticWorkflow = entity.body && entity.body.includes("gh-aw-agentic-workflow:");
      const isAgenticWorkflow = hasWorkflowId || hasAgenticWorkflow;

      if (isAgenticWorkflow) {
        agenticCount++;
      }

      if (!isAgenticWorkflow) {
        continue;
      }

      // Check if has expiration marker with checked checkbox (try both new and legacy formats)
      const match = entity.body ? entity.body.match(EXPIRATION_PATTERN) : null;
      const legacyMatch = !match && entity.body ? entity.body.match(LEGACY_EXPIRATION_PATTERN) : null;

      if (match || legacyMatch) {
        withExpirationCount++;

        // Deduplicate if enabled (discussions may have duplicates across pages)
        if (seenIds) {
          if (seenIds.has(entity.id)) {
            core.warning(`  Skipping duplicate ${config.entityType.slice(0, -1)} #${entity.number} (ID: ${entity.id}) - already seen in previous page`);
            duplicateCount++;
            continue;
          }
          seenIds.add(entity.id);
        }

        const expirationValue = match ? match[1] : legacyMatch ? legacyMatch[1] : "unknown";
        const format = match ? "new" : "legacy";
        core.info(`  Found ${config.entityType.slice(0, -1)} #${entity.number} with expiration marker (${format} format): "${expirationValue}" - ${entity.title}`);
        items.push(entity);
      }
    }

    core.info(`Page ${pageCount} summary: ${agenticCount} agentic ${config.entityType}, ${withExpirationCount} with expiration markers`);

    hasNextPage = result.repository[config.graphqlField].pageInfo.hasNextPage;
    cursor = result.repository[config.graphqlField].pageInfo.endCursor;
  }

  if (config.enableDedupe && duplicateCount > 0) {
    core.warning(`Found and skipped ${duplicateCount} duplicate ${config.entityType} across pages`);
  }

  const uniqueQualifier = config.enableDedupe ? " unique" : "";
  core.info(`Search complete: Scanned ${totalScanned} ${config.entityType} across ${pageCount} pages, found ${items.length}${uniqueQualifier} with expiration markers`);

  const stats = {
    pageCount,
    totalScanned,
  };

  if (config.enableDedupe) {
    stats.duplicateCount = duplicateCount;
  }

  return { items, stats };
}

module.exports = {
  searchEntitiesWithExpiration,
};
