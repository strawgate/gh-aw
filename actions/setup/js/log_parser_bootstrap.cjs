// @ts-check
/// <reference types="@actions/github-script" />

const { generatePlainTextSummary, generateCopilotCliStyleSummary, wrapAgentLogInSection, formatSafeOutputsPreview } = require("./log_parser_shared.cjs");
const { getErrorMessage } = require("./error_helpers.cjs");

/**
 * Bootstrap helper for log parser entry points.
 * Handles common logic for environment variable lookup, file existence checks,
 * content reading (file or directory), and summary emission.
 *
 * @param {Object} options - Configuration options
 * @param {function(string): string|{markdown: string, mcpFailures?: string[], maxTurnsHit?: boolean, logEntries?: Array}} options.parseLog - Parser function that takes log content and returns markdown or result object
 * @param {string} options.parserName - Name of the parser (e.g., "Codex", "Claude", "Copilot")
 * @param {boolean} [options.supportsDirectories=false] - Whether the parser supports reading from directories
 * @returns {Promise<void>}
 */
async function runLogParser(options) {
  const fs = require("fs");
  const path = require("path");
  const { parseLog, parserName, supportsDirectories = false } = options;

  try {
    const logPath = process.env.GH_AW_AGENT_OUTPUT;
    if (!logPath) {
      core.info("No agent log file specified");
      return;
    }

    if (!fs.existsSync(logPath)) {
      core.info(`Log path not found: ${logPath}`);
      return;
    }

    let content = "";

    // Check if logPath is a directory or a file
    const stat = fs.statSync(logPath);
    if (stat.isDirectory()) {
      if (!supportsDirectories) {
        core.info(`Log path is a directory but ${parserName} parser does not support directories: ${logPath}`);
        return;
      }

      // For Copilot, check if conversation.md exists (generated by --share flag)
      // If it exists, use it as the primary source for the step summary
      if (parserName === "Copilot") {
        const conversationMdPath = path.join(logPath, "conversation.md");
        if (fs.existsSync(conversationMdPath)) {
          core.info(`Found conversation.md generated by --share flag, using it for step summary preview`);
          content = fs.readFileSync(conversationMdPath, "utf8");

          // Transform markdown to increase header levels by 1
          // This adjusts the conversation.md headers (# to ##, etc.) for better display in step summary
          const { increaseHeaderLevel } = require("./markdown_transformer.cjs");
          const transformedContent = increaseHeaderLevel(content);

          // Mark this content as already markdown formatted
          // We'll need to adjust the parser to handle this
          const result = {
            markdown: transformedContent,
            isPreformatted: true,
            logEntries: [],
          };

          // Write to step summary, wrapped in details/summary section
          if (result.markdown) {
            const wrappedMarkdown = wrapAgentLogInSection(result.markdown, {
              parserName,
              open: true,
            });
            core.summary.addRaw(wrappedMarkdown);
            await core.summary.write();
            core.info(`Wrote conversation markdown to step summary (${Buffer.byteLength(result.markdown, "utf8")} bytes)`);
          }
          return;
        }
      }

      // Read all log files from the directory and concatenate them
      const files = fs.readdirSync(logPath);
      const logFiles = files.filter(file => file.endsWith(".log") || file.endsWith(".txt"));

      if (logFiles.length === 0) {
        core.info(`No log files found in directory: ${logPath}`);
        return;
      }

      // Sort log files by name to ensure consistent ordering
      logFiles.sort();

      // Concatenate all log files
      for (const file of logFiles) {
        const filePath = path.join(logPath, file);
        const fileContent = fs.readFileSync(filePath, "utf8");

        // Add a newline before this file if the previous content doesn't end with one
        if (content.length > 0 && !content.endsWith("\n")) {
          content += "\n";
        }

        content += fileContent;
      }
    } else {
      // Read the single log file
      content = fs.readFileSync(logPath, "utf8");
    }

    const result = parseLog(content);

    // Handle result that may be a simple string or an object with metadata
    let markdown = "";
    let mcpFailures = [];
    let maxTurnsHit = false;
    let logEntries = null;

    if (typeof result === "string") {
      markdown = result;
    } else if (result && typeof result === "object") {
      markdown = result.markdown || "";
      mcpFailures = result.mcpFailures || [];
      maxTurnsHit = result.maxTurnsHit || false;
      logEntries = result.logEntries || null;
    }

    if (markdown) {
      // Read safe outputs file if available
      let safeOutputsContent = "";
      const safeOutputsPath = process.env.GH_AW_SAFE_OUTPUTS;
      if (safeOutputsPath && fs.existsSync(safeOutputsPath)) {
        try {
          safeOutputsContent = fs.readFileSync(safeOutputsPath, "utf8");
        } catch (error) {
          core.warning(`Failed to read safe outputs file: ${getErrorMessage(error)}`);
        }
      }

      // Generate lightweight plain text summary for core.info and Copilot CLI style for step summary
      if (logEntries && Array.isArray(logEntries) && logEntries.length > 0) {
        // Extract model from init entry if available
        const initEntry = logEntries.find(entry => entry.type === "system" && entry.subtype === "init");
        const model = initEntry?.model || null;

        const plainTextSummary = generatePlainTextSummary(logEntries, {
          model,
          parserName,
        });
        core.info(plainTextSummary);

        // Add safe outputs preview to core.info
        if (safeOutputsContent) {
          const safeOutputsPlainText = formatSafeOutputsPreview(safeOutputsContent, { isPlainText: true });
          if (safeOutputsPlainText) {
            core.info(safeOutputsPlainText);
          }
        }

        // Generate Copilot CLI style markdown for step summary
        const copilotCliStyleMarkdown = generateCopilotCliStyleSummary(logEntries, {
          model,
          parserName,
        });

        // Wrap the agent log in a details/summary section (open by default)
        const wrappedAgentLog = wrapAgentLogInSection(copilotCliStyleMarkdown, {
          parserName,
          open: true,
        });

        // Add safe outputs preview to step summary
        let fullMarkdown = wrappedAgentLog;
        if (safeOutputsContent) {
          const safeOutputsMarkdown = formatSafeOutputsPreview(safeOutputsContent, { isPlainText: false });
          if (safeOutputsMarkdown) {
            fullMarkdown += "\n" + safeOutputsMarkdown;
          }
        }

        core.summary.addRaw(fullMarkdown).write();
      } else {
        // Fallback: just log success message for parsers without log entries
        core.info(`${parserName} log parsed successfully`);

        // Add safe outputs preview to core.info (fallback path)
        if (safeOutputsContent) {
          const safeOutputsPlainText = formatSafeOutputsPreview(safeOutputsContent, { isPlainText: true });
          if (safeOutputsPlainText) {
            core.info(safeOutputsPlainText);
          }
        }

        // Wrap the original markdown in a details/summary section (open by default)
        const wrappedAgentLog = wrapAgentLogInSection(markdown, {
          parserName,
          open: true,
        });

        // Write wrapped markdown to step summary if available
        let fullMarkdown = wrappedAgentLog;
        if (safeOutputsContent) {
          const safeOutputsMarkdown = formatSafeOutputsPreview(safeOutputsContent, { isPlainText: false });
          if (safeOutputsMarkdown) {
            fullMarkdown += "\n" + safeOutputsMarkdown;
          }
        }
        core.summary.addRaw(fullMarkdown).write();
      }
    } else {
      core.error(`Failed to parse ${parserName} log`);
    }

    // Claude-specific guardrail: if no structured log entries were parsed, treat as execution failure.
    // This catches silent startup failures where Claude exits before producing JSON tool activity.
    if (parserName === "Claude" && (!logEntries || logEntries.length === 0)) {
      core.setFailed("Claude execution failed: no structured log entries were produced. This usually indicates a startup or configuration error before tool execution.");
    }

    // Handle MCP server failures if present
    if (mcpFailures && mcpFailures.length > 0) {
      const failedServers = mcpFailures.join(", ");
      core.setFailed(`MCP server(s) failed to launch: ${failedServers}`);
    }

    // Handle max-turns limit if hit
    if (maxTurnsHit) {
      core.setFailed(`Agent execution stopped: max-turns limit reached. The agent did not complete its task successfully.`);
    }
  } catch (error) {
    core.setFailed(error instanceof Error ? error : String(error));
  }
}

// Export for testing and usage
if (typeof module !== "undefined" && module.exports) {
  module.exports = {
    runLogParser,
  };
}
