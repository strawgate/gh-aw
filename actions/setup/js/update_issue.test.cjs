import { describe, it, expect, beforeEach, vi } from "vitest";

// Mock the global objects that GitHub Actions provides
const mockCore = {
  debug: vi.fn(),
  info: vi.fn(),
  notice: vi.fn(),
  warning: vi.fn(),
  error: vi.fn(),
  setFailed: vi.fn(),
  setOutput: vi.fn(),
  summary: {
    addRaw: vi.fn().mockReturnThis(),
    write: vi.fn().mockResolvedValue(),
  },
};

const mockGithub = {
  rest: {
    issues: {
      get: vi.fn(),
      update: vi.fn(),
    },
  },
};

const mockContext = {
  eventName: "issues",
  repo: {
    owner: "testowner",
    repo: "testrepo",
  },
  serverUrl: "https://github.com",
  runId: 12345,
  payload: {
    issue: {
      number: 100,
    },
  },
};

// Set up global mocks
global.core = mockCore;
global.github = mockGithub;
global.context = mockContext;

describe("update_issue.cjs - footer support", () => {
  beforeEach(async () => {
    // Reset all mocks before each test
    vi.clearAllMocks();
    vi.resetModules();

    // Reset environment variables
    process.env.GH_AW_WORKFLOW_NAME = "Test Workflow";

    // Reset mock implementations
    mockGithub.rest.issues.get.mockResolvedValue({
      data: {
        number: 100,
        title: "Test Issue",
        body: "Original body content",
        html_url: "https://github.com/testowner/testrepo/issues/100",
      },
    });

    mockGithub.rest.issues.update.mockResolvedValue({
      data: {
        number: 100,
        title: "Test Issue",
        body: "Updated body",
        html_url: "https://github.com/testowner/testrepo/issues/100",
      },
    });
  });

  describe("Footer addition", () => {
    it("should add footer by default when no operation is specified", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original content",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      // When no operation is specified, it should default to "append" and add footer
      const expectedBody = `Original content\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("Original content");
      expect(expectedBody).toContain("---");
      expect(expectedBody).toContain(newContent);
      expect(expectedBody).toContain("> AI generated by");
      expect(expectedBody).toContain("[Test Workflow]");
      // Original content should come first
      expect(expectedBody.indexOf("Original content")).toBeLessThan(expectedBody.indexOf(newContent));
    });

    it("should add footer when using append operation", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original content",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content to append";
      const expectedBody = `Original content\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      // Verify expected body contains all required parts
      expect(expectedBody).toContain("Original content");
      expect(expectedBody).toContain("---");
      expect(expectedBody).toContain(newContent);
      expect(expectedBody).toContain("> AI generated by");
      expect(expectedBody).toContain("[Test Workflow]");
      // Original content should come first
      expect(expectedBody.indexOf("Original content")).toBeLessThan(expectedBody.indexOf(newContent));
    });

    it("should add footer when using prepend operation", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original content",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content to prepend";
      const expectedBody = `${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)\n\n---\n\nOriginal content`;

      expect(expectedBody).toContain("Original content");
      expect(expectedBody).toContain(newContent);
      expect(expectedBody).toContain("> AI generated by");
      expect(expectedBody).toContain("[Test Workflow]");
      // New content should come first
      expect(expectedBody.indexOf(newContent)).toBeLessThan(expectedBody.indexOf("Original content"));
    });

    it("should use custom workflow name from environment", async () => {
      process.env.GH_AW_WORKFLOW_NAME = "Custom Issue Workflow";

      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      const expectedBody = `Original\n\n---\n\n${newContent}\n\n> AI generated by [Custom Issue Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("Custom Issue Workflow");
      expect(expectedBody).not.toContain("Test Workflow");
    });

    it("should use default workflow name when not set", async () => {
      delete process.env.GH_AW_WORKFLOW_NAME;

      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      const expectedBody = `Original\n\n---\n\n${newContent}\n\n> AI generated by [GitHub Agentic Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("GitHub Agentic Workflow");
    });

    it("should handle null body as empty string", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: null,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      const expectedBody = `\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      // Should work same as empty string
      expect(expectedBody).toContain(newContent);
      expect(expectedBody).toContain("> AI generated by");
    });
  });

  describe("Replace-island operation", () => {
    it("should create new island when not found", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original content",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "Island content";
      const expectedBody = `Original content\n\n---\n\n<!-- gh-aw-island-start:12345 -->\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)\n<!-- gh-aw-island-end:12345 -->`;

      expect(expectedBody).toContain("Original content");
      expect(expectedBody).toContain("Island content");
      expect(expectedBody).toContain("<!-- gh-aw-island-start:12345 -->");
      expect(expectedBody).toContain("<!-- gh-aw-island-end:12345 -->");
      expect(expectedBody).toContain("> AI generated by");
    });

    it("should replace existing island content", async () => {
      const existingBody = "Before\n<!-- gh-aw-island-start:12345 -->\nOld island\n<!-- gh-aw-island-end:12345 -->\nAfter";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: existingBody,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New island";
      const expectedBody = `Before\n<!-- gh-aw-island-start:12345 -->\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)\n<!-- gh-aw-island-end:12345 -->\nAfter`;

      expect(expectedBody).toContain("Before");
      expect(expectedBody).toContain("After");
      expect(expectedBody).toContain("New island");
      expect(expectedBody).not.toContain("Old island");
      expect(expectedBody).toContain("> AI generated by");
    });
  });

  describe("Replace operation", () => {
    it("should replace entire body and add footer", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original content that will be completely replaced",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "Completely new body content";
      const expectedBody = `${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      // With replace operation, the original body is completely replaced but footer is added
      expect(expectedBody).not.toContain("Original content");
      expect(expectedBody).toContain(newContent);
      expect(expectedBody).toContain("> AI generated by");
      expect(expectedBody).toContain("[Test Workflow]");
    });
  });

  describe("Edge cases and special content", () => {
    it("should handle very long content in append", async () => {
      const longContent = "A".repeat(10000);
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const expectedBody = `Original\n\n---\n\n${longContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain(longContent);
      expect(expectedBody.length).toBeGreaterThan(10000);
    });

    it("should handle unicode and emoji characters", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original ä½ å¥½",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content ä¸–ç•Œ ðŸš€ ðŸŽ‰";
      const expectedBody = `Original ä½ å¥½\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("ä½ å¥½");
      expect(expectedBody).toContain("ä¸–ç•Œ ðŸš€ ðŸŽ‰");
    });

    it("should handle markdown code blocks", async () => {
      const codeBlock = "```javascript\nconst x = 1;\nconsole.log(x);\n```";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: codeBlock,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      const expectedBody = `${codeBlock}\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("```javascript");
      expect(expectedBody).toContain("const x = 1;");
      expect(expectedBody).toContain("```");
    });

    it("should handle markdown tables", async () => {
      const table = "| Column 1 | Column 2 |\n|----------|----------|\n| Value 1  | Value 2  |";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: table,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      const expectedBody = `${table}\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("| Column 1 | Column 2 |");
      expect(expectedBody).toContain("| Value 1  | Value 2  |");
    });

    it("should handle HTML comments in body", async () => {
      const bodyWithComments = "Content\n<!-- HTML comment -->\nMore content";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: bodyWithComments,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      const expectedBody = `${bodyWithComments}\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("<!-- HTML comment -->");
      expect(expectedBody).toContain("More content");
    });

    it("should handle task lists", async () => {
      const taskList = "## Tasks\n- [x] Completed task\n- [ ] Pending task\n- [x] Another completed";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: taskList,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      const expectedBody = `${taskList}\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("- [x] Completed task");
      expect(expectedBody).toContain("- [ ] Pending task");
    });

    it("should handle content with multiple separators", async () => {
      const bodyWithSeparators = "Content 1\n\n---\n\nContent 2\n\n---\n\nContent 3";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: bodyWithSeparators,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New content";
      const expectedBody = `${bodyWithSeparators}\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      // Should have 2 existing separators + 1 new = 3 total
      const separatorCount = (expectedBody.match(/---/g) || []).length;
      expect(separatorCount).toBe(3);
    });

    it("should handle empty string content", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "";
      const expectedBody = `Original\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("Original");
      expect(expectedBody).toContain("> AI generated by");
    });

    it("should handle content with newlines at boundaries", async () => {
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: "Original\n\n\n",
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "\n\nNew content\n\n";
      const expectedBody = `Original\n\n\n\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("Original");
      expect(expectedBody).toContain("New content");
    });

    it("should handle special markdown characters", async () => {
      const specialChars = "Content with *asterisks*, _underscores_, and `backticks`";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: specialChars,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New [link](http://example.com) and **bold**";
      const expectedBody = `${specialChars}\n\n---\n\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)`;

      expect(expectedBody).toContain("*asterisks*");
      expect(expectedBody).toContain("_underscores_");
      expect(expectedBody).toContain("`backticks`");
      expect(expectedBody).toContain("[link](http://example.com)");
      expect(expectedBody).toContain("**bold**");
    });

    it("should handle multiple islands with different run IDs in replace-island", async () => {
      const existingBody = "<!-- gh-aw-island-start:99999 -->\nOther island\n<!-- gh-aw-island-end:99999 -->";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: existingBody,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "New island";
      // Should append because island with run ID 12345 doesn't exist
      const expectedBody = `${existingBody}\n\n---\n\n<!-- gh-aw-island-start:12345 -->\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)\n<!-- gh-aw-island-end:12345 -->`;

      expect(expectedBody).toContain("Other island");
      expect(expectedBody).toContain("New island");
      expect(expectedBody).toContain("<!-- gh-aw-island-start:99999 -->");
      expect(expectedBody).toContain("<!-- gh-aw-island-start:12345 -->");
    });

    it("should preserve content outside island when replacing", async () => {
      const existingBody = "# Title\n\n<!-- gh-aw-island-start:12345 -->\nOld\n<!-- gh-aw-island-end:12345 -->\n\n## Footer";
      mockGithub.rest.issues.get.mockResolvedValueOnce({
        data: {
          number: 100,
          title: "Test Issue",
          body: existingBody,
          html_url: "https://github.com/testowner/testrepo/issues/100",
        },
      });

      const newContent = "Updated content";
      const expectedBody = `# Title\n\n<!-- gh-aw-island-start:12345 -->\n${newContent}\n\n> AI generated by [Test Workflow](https://github.com/testowner/testrepo/actions/runs/12345)\n<!-- gh-aw-island-end:12345 -->\n\n## Footer`;

      expect(expectedBody).toContain("# Title");
      expect(expectedBody).toContain("## Footer");
      expect(expectedBody).toContain("Updated content");
      expect(expectedBody).not.toContain("Old");
    });
  });
});

describe("update_issue.cjs - allow_body configuration", () => {
  beforeEach(async () => {
    // Reset all mocks before each test
    vi.clearAllMocks();
    vi.resetModules();
  });

  it("should allow body updates when allow_body is true", async () => {
    const { buildIssueUpdateData } = await import("./update_issue.cjs");

    const item = {
      body: "New body content",
    };

    const config = {
      allow_body: true,
    };

    const result = buildIssueUpdateData(item, config);

    expect(result.success).toBe(true);
    expect(result.data._rawBody).toBe("New body content");
    expect(result.data._operation).toBe("append");
  });

  it("should allow body updates when allow_body is not specified (defaults to true)", async () => {
    const { buildIssueUpdateData } = await import("./update_issue.cjs");

    const item = {
      body: "New body content",
    };

    const config = {};

    const result = buildIssueUpdateData(item, config);

    expect(result.success).toBe(true);
    expect(result.data._rawBody).toBe("New body content");
    expect(result.data._operation).toBe("append");
  });

  it("should block body updates when allow_body is false", async () => {
    const { buildIssueUpdateData } = await import("./update_issue.cjs");

    const item = {
      body: "New body content",
    };

    const config = {
      allow_body: false,
    };

    const result = buildIssueUpdateData(item, config);

    expect(result.success).toBe(true);
    expect(result.data._rawBody).toBeUndefined();
    expect(result.data._operation).toBeUndefined();
    expect(mockCore.warning).toHaveBeenCalledWith("Body update not allowed by safe-outputs configuration");
  });

  it("should still allow other fields when body is blocked", async () => {
    const { buildIssueUpdateData } = await import("./update_issue.cjs");

    const item = {
      title: "New Title",
      body: "New body content",
      status: "closed",
      labels: ["bug", "enhancement"],
    };

    const config = {
      allow_body: false,
    };

    const result = buildIssueUpdateData(item, config);

    expect(result.success).toBe(true);
    expect(result.data.title).toBe("New Title");
    expect(result.data.state).toBe("closed");
    expect(result.data.labels).toEqual(["bug", "enhancement"]);
    expect(result.data._rawBody).toBeUndefined();
    expect(mockCore.warning).toHaveBeenCalledWith("Body update not allowed by safe-outputs configuration");
  });

  it("should respect allow_body true with explicit operation", async () => {
    const { buildIssueUpdateData } = await import("./update_issue.cjs");

    const item = {
      body: "New body content",
      operation: "prepend",
    };

    const config = {
      allow_body: true,
    };

    const result = buildIssueUpdateData(item, config);

    expect(result.success).toBe(true);
    expect(result.data._rawBody).toBe("New body content");
    expect(result.data._operation).toBe("prepend");
  });

  it("should block body update even with explicit operation when allow_body is false", async () => {
    const { buildIssueUpdateData } = await import("./update_issue.cjs");

    const item = {
      body: "New body content",
      operation: "replace",
    };

    const config = {
      allow_body: false,
    };

    const result = buildIssueUpdateData(item, config);

    expect(result.success).toBe(true);
    expect(result.data._rawBody).toBeUndefined();
    expect(result.data._operation).toBeUndefined();
    expect(mockCore.warning).toHaveBeenCalledWith("Body update not allowed by safe-outputs configuration");
  });
});
