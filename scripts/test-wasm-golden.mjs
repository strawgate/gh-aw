#!/usr/bin/env node

/**
 * Wasm Golden Test Runner
 *
 * Builds the gh-aw wasm module, loads it in Node.js, compiles workflow fixtures,
 * and compares the output against golden files generated by the Go test suite.
 *
 * Usage:
 *   node scripts/test-wasm-golden.mjs [--update]
 *
 * The --update flag regenerates golden files from wasm output.
 *
 * Prerequisites:
 *   - Go 1.23+ installed
 *   - Run `make build-wasm` first, or this script will build it
 */

import { readFileSync, readdirSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { join, resolve, basename } from "path";
import { execSync } from "child_process";
import { createRequire } from "module";

const ROOT = resolve(import.meta.dirname, "..");
const FIXTURES_DIR = join(
  ROOT,
  "pkg/workflow/testdata/wasm_golden/fixtures"
);
const GOLDEN_DIR = join(
  ROOT,
  "pkg/workflow/testdata/wasm_golden"
);
const WASM_FILE = join(ROOT, "gh-aw.wasm");
const UPDATE_MODE = process.argv.includes("--update");

// Fixtures with known wasm-vs-native divergence due to filesystem limitations.
// The wasm environment cannot fully replicate the native compiler's behavior for
// workflow_run triggers (missing fork validation, zizmor annotations) and
// pre_activation job generation. These are tracked for future resolution.
const KNOWN_WASM_DIVERGENCE = new Set([
  "ci-doctor",            // workflow_run trigger: missing zizmor annotation + fork validation
  "copilot-cli-deep-research", // pre_activation job generated differently in wasm
  "dev-hawk",             // workflow_run trigger: missing zizmor annotation + fork validation
]);

// ── Build wasm if needed ─────────────────────────────────────────────
function ensureWasmBuilt() {
  if (!existsSync(WASM_FILE)) {
    console.log("Building wasm module...");
    execSync("make build-wasm", { cwd: ROOT, stdio: "inherit" });
  }
  console.log(`Using wasm module: ${WASM_FILE}`);
}

// ── Load Go wasm_exec.js runtime ─────────────────────────────────────
function loadWasmExecJs() {
  const goRoot = execSync("go env GOROOT", { encoding: "utf8" }).trim();
  // Go 1.24+ moved wasm_exec.js from misc/wasm/ to lib/wasm/
  let wasmExecPath = join(goRoot, "lib/wasm/wasm_exec.js");
  if (!existsSync(wasmExecPath)) {
    wasmExecPath = join(goRoot, "misc/wasm/wasm_exec.js");
  }
  if (!existsSync(wasmExecPath)) {
    throw new Error(`wasm_exec.js not found in ${goRoot}/lib/wasm/ or ${goRoot}/misc/wasm/`);
  }
  // wasm_exec.js expects a global `require` for Node.js
  globalThis.require = createRequire(import.meta.url);
  // Load the wasm_exec.js script (it defines globalThis.Go)
  const script = readFileSync(wasmExecPath, "utf8");
  // Use indirect eval to run in global scope
  const fn = new Function(script);
  fn();
}

// ── Instantiate wasm module ──────────────────────────────────────────
async function instantiateWasm() {
  const go = new globalThis.Go();
  const wasmBytes = readFileSync(WASM_FILE);
  const result = await WebAssembly.instantiate(wasmBytes, go.importObject);
  // Start the Go runtime (it blocks, runs in background)
  go.run(result.instance);
  // Wait a moment for the Go runtime to register the global function
  await new Promise((r) => setTimeout(r, 200));

  if (typeof globalThis.compileWorkflow !== "function") {
    throw new Error(
      "compileWorkflow function not registered by wasm module. " +
        "Ensure cmd/gh-aw-wasm/main.go sets js.Global().Set('compileWorkflow', ...)"
    );
  }
  console.log("Wasm module loaded, compileWorkflow function available");
  return globalThis.compileWorkflow;
}

// ── Load all shared components as virtual files ─────────────────────
// The wasm binary needs access to shared components for both import
// resolution and security scanning (runtime-import validation).
let _sharedFilesCache = null;
function loadAllSharedFiles() {
  if (_sharedFilesCache) return _sharedFilesCache;
  const files = {};
  const sharedDir = join(FIXTURES_DIR, "shared");
  if (!existsSync(sharedDir)) return null;

  for (const f of readdirSync(sharedDir)) {
    if (f.endsWith(".md")) {
      files[`shared/${f}`] = readFileSync(join(sharedDir, f), "utf8");
    }
  }
  const mcpDir = join(sharedDir, "mcp");
  if (existsSync(mcpDir)) {
    for (const f of readdirSync(mcpDir)) {
      if (f.endsWith(".md")) {
        files[`shared/mcp/${f}`] = readFileSync(join(mcpDir, f), "utf8");
      }
    }
  }
  _sharedFilesCache = Object.keys(files).length > 0 ? files : null;
  return _sharedFilesCache;
}

// ── Load fixtures ────────────────────────────────────────────────────
function loadFixtures() {
  const sharedFiles = loadAllSharedFiles();
  const files = readdirSync(FIXTURES_DIR).filter((f) => f.endsWith(".md"));
  return files.map((f) => ({
    name: f.replace(/\.md$/, ""),
    filename: f,
    content: readFileSync(join(FIXTURES_DIR, f), "utf8"),
    virtualFiles: sharedFiles,
  }));
}

// ── Load golden file ─────────────────────────────────────────────────
function loadGoldenFile(testName) {
  // Golden files follow the charmbracelet/x/exp/golden convention:
  // testdata/TestName/subtest_name.golden
  const goldenPath = join(
    GOLDEN_DIR,
    "TestWasmGolden_CompileFixtures",
    testName + ".golden"
  );
  if (!existsSync(goldenPath)) {
    return null;
  }
  return readFileSync(goldenPath, "utf8");
}

// ── Save wasm golden file ────────────────────────────────────────────
function saveWasmGoldenFile(testName, content) {
  const dir = join(GOLDEN_DIR, "WasmBinary");
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
  const goldenPath = join(dir, testName + ".golden");
  writeFileSync(goldenPath, content);
}

// ── Main test runner ─────────────────────────────────────────────────
async function main() {
  ensureWasmBuilt();
  loadWasmExecJs();
  const compileWorkflow = await instantiateWasm();
  const fixtures = loadFixtures();

  console.log(`\nRunning wasm golden tests on ${fixtures.length} fixtures...\n`);

  let passed = 0;
  let failed = 0;
  let skipped = 0;
  const failures = [];

  for (const fixture of fixtures) {
    process.stdout.write(`  ${fixture.name} ... `);

    // Skip fixtures with known wasm-vs-native divergence
    if (!UPDATE_MODE && KNOWN_WASM_DIVERGENCE.has(fixture.name)) {
      console.log("SKIP (known wasm divergence)");
      skipped++;
      continue;
    }

    // Load the golden file once (null if it doesn't exist)
    const goldenYaml = loadGoldenFile(fixture.name);

    // Skip fixtures that have no golden file (Go test also skipped them)
    // unless we're in update mode
    if (!UPDATE_MODE && goldenYaml === null) {
      console.log("SKIP (no golden file)");
      skipped++;
      continue;
    }

    try {
      const result = await compileWorkflow(fixture.content, fixture.virtualFiles, fixture.filename);

      if (result.error) {
        console.log("FAIL (compilation error)");
        failures.push({
          name: fixture.name,
          error: `Wasm compilation error: ${result.error}`,
        });
        failed++;
        continue;
      }

      const wasmYaml = result.yaml;

      if (UPDATE_MODE) {
        saveWasmGoldenFile(fixture.name, wasmYaml);
        console.log("UPDATED");
        passed++;
        continue;
      }

      if (wasmYaml === goldenYaml) {
        console.log("PASS");
        passed++;
      } else {
        console.log("FAIL (output differs from golden)");

        // Find first difference
        const wasmLines = wasmYaml.split("\n");
        const goldenLines = goldenYaml.split("\n");
        for (
          let i = 0;
          i < Math.min(wasmLines.length, goldenLines.length);
          i++
        ) {
          if (wasmLines[i] !== goldenLines[i]) {
            failures.push({
              name: fixture.name,
              error: `First diff at line ${i + 1}:\n  wasm:   ${JSON.stringify(wasmLines[i])}\n  golden: ${JSON.stringify(goldenLines[i])}`,
            });
            break;
          }
        }
        if (wasmLines.length !== goldenLines.length) {
          failures.push({
            name: fixture.name,
            error:
              (failures.length > 0 ? failures[failures.length - 1].error + "\n" : "") +
              `Line count: wasm=${wasmLines.length}, golden=${goldenLines.length}`,
          });
        }
        failed++;
      }
    } catch (err) {
      // Match Go test behavior: skip fixtures that cannot compile in the
      // wasm/js environment. Some fixtures compile fine with disk access
      // (Go test) but fail in wasm due to missing filesystem support.
      const msg = err.message || String(err);
      const isWasmLimitation =
        msg.includes("not implemented on js") ||
        msg.includes("import file not found") ||
        msg.includes("must be within .github folder") ||
        msg.includes("fuzzy cron expression") ||
        msg.includes("Configuration error") ||
        msg.includes("Validation failed") ||
        msg.includes("file not found in virtual filesystem");
      if (isWasmLimitation) {
        console.log("SKIP (cannot compile in wasm)");
        skipped++;
      } else {
        console.log("ERROR");
        failures.push({
          name: fixture.name,
          error: `Exception: ${msg}`,
        });
        failed++;
      }
    }
  }

  // Summary
  console.log(`\n${"=".repeat(60)}`);
  console.log(
    `Results: ${passed} passed, ${failed} failed, ${skipped} skipped (${fixtures.length} total)`
  );

  if (failures.length > 0) {
    console.log(`\nFailures:`);
    for (const f of failures) {
      console.log(`\n  ${f.name}:`);
      console.log(`    ${f.error.replace(/\n/g, "\n    ")}`);
    }
  }

  if (UPDATE_MODE) {
    console.log(`\nWasm golden files updated in ${GOLDEN_DIR}/WasmBinary/`);
  }

  console.log();
  process.exit(failed > 0 ? 1 : 0);
}

main().catch((err) => {
  console.error("Fatal error:", err);
  process.exit(2);
});
